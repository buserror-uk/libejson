/*
 * IF YOU ARE LOOKING AT A .c FILE, YOUR ARE LOOKING AT THE WRONG ONE
 *
 * The .c file is autogenerated from a .rl source file for 'ragel'
 * parser generator.
 */
/*
	This file is part of libejson.

	(C) 2010 Michel Pollet <buserror@gmail.com>
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "ejson.h"

%%{
	machine ejson_str;
	write data;
}%%

/* This converts uni_glyph from a \uXXXX to a UTF8 sequence */
static char *
ejson_append_utf8_glyph(
	char * dst,
	uint32_t uni_glyph )
{
	if (uni_glyph < 128) {
		*dst++ = (char)uni_glyph;
		return dst;	// that was easy
	}
	uint8_t *cur = (uint8_t*)dst;

	uint32_t mask = ~0x7ff;
	int bits = 6;
	int header = 5;

	while ((uni_glyph & mask) && bits <= 24) {
		mask = mask << 6;
		bits += 6; header--;
	}
	*cur++ = (0xfe << header) | (uint8_t)(uni_glyph >> (bits));
	bits -= 6;
	while (bits >= 0) {
		*cur++ = 0x80 | ((uint8_t)(uni_glyph >> bits) & 0x3f);
		bits -= 6;
	}
	return (char*)cur;
}

int
ejson_parse_string(
	const char *str,
	const char *end,
	char *out)
{
	const char *p = str,
			*pe = end ? end : str + strlen( str ),
			*eof = pe;
	int cs;
	uint16_t u = 0;

	out = out ? out : (char*)str;
	%%{
		machine ejson_str;

		xxdigit = (
			([0-9] @{ u = (u << 4) | (fc - '0'); }) |
			([a-f] @{ u = (u << 4) | (fc - 'a' + 0xa); }) |
			([A-F] @{ u = (u << 4) | (fc - 'A' + 0xa); })
		);
		utf16 = ( xxdigit{4,} ) >{ u = 0; } @{
			out = ejson_append_utf8_glyph(out, u);
		};

		normal = any @{*out++ = fc;};
		escape =
				('"' %{ *out++ = '"'; } ) |
				('\\' %{ *out++ = '\\'; } ) |
				('t' %{ *out++ = '\t'; } )  |
				('b' %{ *out++ = '\b'; } )  |
				('f' %{ *out++ = '\f'; } )  |
				('n' %{ *out++ = '\n'; } )  |
				('r' %{ *out++ = '\r'; } )  |
				('u' utf16 ) |
				(( any -- [\\tbfntu\"] ) %{*out++ = fc;})
			;
		main := (
			('\\' escape) |
			( normal -- '\\' )
		)*;

		# Initialize and execute.
		write init;
		write exec;
	}%%
	*out = 0;

	return 0;
}

%%{
	machine ejson;
	write data;
}%%

int
ejson_parse(
	ejson_driver_t *d,
	const char *str )
{
	const char *p = str, *pe = str + strlen( str ), *eof = pe;
	int cs;
	int *stack = NULL, stack_size = 0, top = 0;
	int integer_sign = 0;	// for integer decode
	const char * float_start = NULL;
	char float_value[32];
	ejson_driver_value_t v = {};
	uint32_t b64 = 0;
	int b64_cnt = 0;
	uint8_t * base64 = NULL;
	int base64_hold = 0;
	const char * _value_start = NULL; /* only used as error helper */
	int err = 0;

	%%{
		machine ejson;
		action obj_field_list_start { d->open_object(d); }
		action obj_field_list_done { d->close_object(d); }
		action obj_value_list_start { d->open_array(d); }
		action obj_value_list_done { d->close_array(d); }
		action obj_create_name { d->set_name(d, &v); }
		action obj_set_flag { if (d->add_flag) d->add_flag(d, &v); }
		action obj_set_string { d->set_value(d, ejson_driver_type_string, &v); }
		action obj_set_integer { d->set_value(d, ejson_driver_type_integer, &v); }
		action obj_set_float { d->set_value(d, ejson_driver_type_float, &v); }
		action obj_set_hex { d->set_value(d, ejson_driver_type_hex, &v); }
		action obj_set_true { v.u.v_bool = 1; d->set_value(d, ejson_driver_type_bool, &v); }
		action obj_set_false { v.u.v_bool = 0; d->set_value(d, ejson_driver_type_bool, &v); }
		action obj_set_null { d->set_value(d, ejson_driver_type_null, NULL); }

		prepush {
			// prepush -- make sure the stack has the space for it
			if (top == stack_size) {
				stack_size += 8;
				stack = realloc(stack, stack_size * sizeof(int));
			}
		}
		action obj_start_data {
			if (d->open_data) {
				d->open_data(d);
				base64_hold = 0;
				if (!base64)
					base64 = (uint8_t*)alloca(128);
			}
		}
		action obj_flush_data {
			if (base64_hold + b64_cnt >= 128) {
				if (d->add_data)
					d->add_data(d, base64, base64_hold);
				base64_hold = 0;
			}
			if (base64)
				for (int s=16, i = 0; i < b64_cnt; i++, s-=8)
					base64[base64_hold++] = (b64 >> s) & 0xff;
		}
		action obj_end_data {
			if (base64_hold && d->add_data)
				d->add_data(d, base64, base64_hold);
			if (d->close_data) d->close_data(d);
		}
		skipline := [^\n]* '\n' @{ fret; };
		comment = '//' @{ fhold;fcall skipline ; };
		WB = (
			[ \t\n]+
		);
		W = (
			WB |
			comment
		)*;
		WN = [ \t\n]**;

		#
		# quoted or unquoted string
		#
		action str_init { v.u.v_str.start = v.u.v_str.end = fpc; }
		action str_done { v.u.v_str.end = fpc; }

		dstring = '"' ((([^"] | '\\"')**) >str_init %str_done)  '"';
		# extension to JSON: single quoted strings
		sstring = '\'' ((([^'] | '\\\'')**) >str_init %str_done)  '\'';
		string = ( dstring | sstring );

		ident = ((alnum | '_') (alnum | '_')**) >str_init %str_done;

		#
		# negative/positive Integer
		#
		action integer_init { v.u.v_int = 0; integer_sign = 1; }
		action integer_minus { integer_sign = -1; }
		action integer_digit { v.u.v_int = (v.u.v_int * 10) + (fc - '0'); }
		action integer_done {  v.u.v_int *= integer_sign; }

		integer = (('-' @integer_minus | '+')? (digit+ @integer_digit))
			>integer_init %integer_done;

		#
		# hex integer
		#
		xxdigit = (
			([0-9] @{ v.u.v_int = (v.u.v_int << 4) | (fc - '0'); }) |
			([a-f] @{ v.u.v_int = (v.u.v_int << 4) | (fc - 'a' + 0xa); }) |
			([A-F] @{ v.u.v_int = (v.u.v_int << 4) | (fc - 'A' + 0xa); })
		);
		hex = (('-' @integer_minus | '+')?( '0x' xxdigit+))
			>integer_init %integer_done;

		#
		# float/double value
		#
		action float_init { float_start = fpc; }
		action float_done {
			int l = fpc - float_start;
			if (l >= sizeof(float_value)) {
				l = sizeof(float_value)-1;
			}
			memcpy(float_value, float_start, l);
			float_value[l] = 0;
			double lf = 0.0;
			sscanf(float_value, "%lg", &lf);
			v.u.v_float = lf;
			float_start = NULL;
		}
		#
		# float values
		# Handle exponential notation. Not JSON, but javascript does it.
		# Also allows specifying for example 5f for a float value of 5
		float = (
			('-' | '+')? (
			#	(digit+ ('f'|'d')?) |
				(digit* ('.' digit+)) |
				(digit+ ('.' digit+)? ('e' ('-')? digit+))
			)
		) >float_init %float_done;

		#
		# base64 decoder
		#
		base64_char = (
			([A-Z] @{ b64 = (b64 << 6) | (fc - 'A'); }) |
			([a-z] @{ b64 = (b64 << 6) | (fc - 'a' + 26 ); }) |
			([0-9] @{ b64 = (b64 << 6) | (fc - '0' + 52 ); }) |
			('+' @{ b64 = (b64 << 6) | 62; }) |
			('/' @{ b64 = (b64 << 6) | 63; })
		);
		base64_pad = '=' @{ b64 = (b64 << 6); };
		base64_four = (
			base64_char base64_char base64_char base64_char
		) %{ b64_cnt = 3; } %obj_flush_data;
		base64_padder = (
			base64_char base64_char
			(
				(( base64_char base64_pad )
					%{ b64_cnt = 2; } ) |
				(( base64_pad base64_pad )
					%{ b64_cnt = 1; } )
			)
		) %obj_flush_data;

		base64 = ( base64_four** (base64_four | base64_padder) ) >{b64 = 0;}
				%err{
					err = EJSON_ERR_BASE64;
					if (d->error)
						d->error(d->refcon, err, p);
				//	printf("### base64 Error : '%s'\n", p);
				};

		#
		# ejson value, extended
		#
		ejson_value = (
			(string %obj_set_string) |
			(integer %obj_set_integer) |
			(hex %obj_set_hex ) |
			(float %obj_set_float) |
			('true' %obj_set_true) |
			('false' %obj_set_false) |
			('null' %obj_set_null) |
			('{' @{ fhold; fcall obj_field_list; } ) |
			('[' @{ fhold; fcall ejson_value_list; } ) |
			(('%' (W base64)* W '%')
				>obj_start_data %obj_end_data)
		) >{ _value_start = p; }
				%err{
					err = EJSON_ERR_VALUE;
					if (d->error)
						d->error(d->refcon, err, _value_start);
				//	printf("### Value[%d] Error : '%s'\n", top, _value_start);
				};

		ejson_value_list := (
			'[' W
				( W (ejson_value (W ',' W ejson_value)* ) W ','? )?
			W ']'
		) >obj_value_list_start @obj_value_list_done @{ fret; }
				%err{
					err = EJSON_ERR_VALUE_LIST;
					if (d->error)
						d->error(d->refcon, err, p);
				//	printf("### Array[%d] Error : '%s'\n", top, p);
				};

		obj_field_flag = ( ident ) %obj_set_flag;
		obj_field_flags = (
			'(' W obj_field_flag (W ',' W obj_field_flag)* W  ','? W ')'
		);
		obj_field = ((string | ident) %obj_create_name) W obj_field_flags? W ':' W ejson_value;

		obj_field_list := (
			'{' W
				( W (obj_field (W ',' W obj_field)** ) W ','? )?
			 W '}'
		) >obj_field_list_start @obj_field_list_done @{ fret; }
				%err{
					err = EJSON_ERR_VALUE_OBJECT;
					if (d->error)
						d->error(d->refcon, err, p);
					printf("### Object[%d] Error : '%s'\n", top, p);
				};

		main := (
			W ejson_value W
		) %err{
			err = EJSON_ERR;
			if (d->error)
				d->error(d->refcon, err, p);
		//	printf("### ejson Error : '%s'\n", p);
		};

		# Initialize and execute.
		write init;
		write exec;
	}%%
	if (stack) free(stack);
	return err;
};
